import { $TRACK, createMemo, createSignal, onCleanup, getOwner } from "solid-js";
import { isServer } from "solid-js/web";
import { useRouter } from "../routing";
import { redirectStatusCodes } from "../utils";
import { cacheKeyOp, hashKey, revalidate } from "./cache";
export const actions = /* #__PURE__ */ new Map();
export function useSubmissions(fn, filter) {
    const router = useRouter();
    const subs = createMemo(() => router.submissions[0]().filter(s => s.url === fn.toString() && (!filter || filter(s.input))));
    return new Proxy([], {
        get(_, property) {
            if (property === $TRACK)
                return subs();
            if (property === "pending")
                return subs().some(sub => !sub.result);
            return subs()[property];
        }
    });
}
export function useSubmission(fn, filter) {
    const submissions = useSubmissions(fn, filter);
    return new Proxy({}, {
        get(_, property) {
            return submissions[submissions.length - 1]?.[property];
        }
    });
}
export function useAction(action) {
    const router = useRouter();
    return (...args) => action.apply(router, args);
}
export function action(fn, name) {
    function mutate(...variables) {
        const p = fn(...variables);
        const [result, setResult] = createSignal();
        let submission;
        const router = this;
        async function handler(res) {
            const data = await handleResponse(res, router.navigatorFactory());
            data ? setResult({ data }) : submission.clear();
            return data;
        }
        router.submissions[1](s => [
            ...s,
            (submission = {
                input: variables,
                url,
                get result() {
                    return result()?.data;
                },
                get pending() {
                    return !result();
                },
                clear() {
                    router.submissions[1](v => v.filter(i => i.input !== variables));
                },
                retry() {
                    setResult(undefined);
                    const p = fn(...variables);
                    p.then(handler, handler);
                    return p;
                }
            })
        ]);
        p.then(handler, handler);
        return p;
    }
    const url = fn.url ||
        (name && `action:${name}`) ||
        (!isServer ? `action:${hashString(fn.toString())}` : "");
    return toAction(mutate, url);
}
function toAction(fn, url) {
    fn.toString = () => {
        if (!url)
            throw new Error("Client Actions need explicit names if server rendered");
        return url;
    };
    fn.with = function (...args) {
        const newFn = function (...passedArgs) {
            return fn.call(this, ...args, ...passedArgs);
        };
        const uri = new URL(url, "http://sar");
        uri.searchParams.set("args", hashKey(args));
        return toAction(newFn, (uri.protocol === "action:" ? uri.protocol : "") + uri.pathname + uri.search);
    };
    fn.url = url;
    if (!isServer) {
        actions.set(url, fn);
        getOwner() && onCleanup(() => actions.delete(url));
    }
    return fn;
}
const hashString = (s) => s.split("").reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0);
async function handleResponse(response, navigate) {
    let data;
    let keys;
    if (response instanceof Response) {
        if (response.headers.has("X-Revalidate"))
            keys = response.headers.get("X-Revalidate").split(",");
        if (response.customBody)
            data = await response.customBody();
        if (redirectStatusCodes.has(response.status)) {
            const locationUrl = response.headers.get("Location") || "/";
            if (locationUrl.startsWith("http")) {
                window.location.href = locationUrl;
            }
            else {
                navigate(locationUrl);
            }
        }
    }
    else
        data = response;
    // invalidate
    cacheKeyOp(keys, entry => (entry[0] = 0));
    // trigger revalidation
    await revalidate(keys, false);
    return data;
}
